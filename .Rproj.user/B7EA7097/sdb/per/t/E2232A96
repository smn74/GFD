{
    "contents" : "par_old <- par()$oma\non.exit(par(oma = par_old))\n\n#' Tests for general factorial designs\n#' \n#' The GFD function calculates the Wald-type statistic (WTS), the ANOVA-type \n#' statistic (ATS) as well as a permutation version of the WTS for general \n#' factorial designs.\n#' \n#' @param formula A model \\code{\\link{formula}} object. The left hand side\n#'   contains the response variable and the right hand side contains the factor\n#'   variables of interest. An interaction term must be specified.\n#' @param data A data.frame, list or environment containing the variables in \n#'   \\code{formula}. The default option is \\code{NULL}.\n#' @param nperm The number of permutations used for calculating the permuted \n#'   Wald-type statistic. The default option is 10000.\n#' @param alpha A number specifying the significance level; the default is 0.05.\n#' @param plot_CI An indicator for whether a plot of the results should be \n#'   shown; the default is \\code{FALSE}.\n#' @param Title A title for the plot. The default is \\code{NULL}.\n#' @param line_width A number specifying the \\code{lwd}-option for the plots.\n#'   The default is 2.\n#'   \n#' @details The package provides the Wald-type statistic, a permuted version\n#'   thereof as well as the ANOVA-type statistic for general factorial designs,\n#'   even with non-normal error terms and/or heteroscedastic variances. It is\n#'   implemented for both crossed and hierarchically nested designs and allows\n#'   for an arbitrary number of factor combinations as well as different sample\n#'   sizes in the crossed design.\n\n#'   \n#' @return A \\code{GFD} object containing the following components:\n#' \\item{Descriptive}{Some descriptive statistics of the data for all factor\n#'   level combinations. Displayed are the number of individuals per factor\n#'   level combination, the mean, variance and 100*(1-alpha)\\% confidence\n#'   intervals.}\n#'  \\item{WTS}{The value of the WTS along with degrees of freedom of the central chi-square distribution and p-value, as well as the p-value of the permutation procedure.}\n#'  \\item{ATS}{The value of the ATS, degrees of freedom of the central F distribution and the corresponding p-value.}\n#' \n#' @examples\n#' GFD(weightgain ~ source * type, data = HSAUR::weightgain)\n#' \n#' data(startup)\n#' model <- GFD(Costs ~ company, data = startup)\n#' summary(model)\n#' \n#' @references Friedrich, S., Konietschke, F., Pauly, M.(2015). GFD - An R-package\n#' for the Analysis of General Factorial Designs - along with a Graphical User Interface. Submitted to Journal of Statistical Software.\n#' \n#' Pauly, M., Brunner, E., Konietschke, F.(2015). Asymptotic Permutation Tests in General Factorial Designs. Journal of the Royal Statistical Society - Series B 77, 461-473.\n#' \n#' @import RGtk2\n#' \n#' @importFrom graphics axis legend par plot title\n#' @importFrom stats ecdf formula model.frame pchisq pf qt terms var\n#' @importFrom utils read.table\n#' \n#' @export\n\nGFD <- function(formula, data = NULL, nperm = 10000,\n                alpha = 0.05, plot_CI = FALSE, Title = NULL,\n                line_width = 2){\n  \n  input_list <- list(formula = formula, data = data,\n                     nperm = nperm, alpha = alpha,\n                     plot_CI = plot_CI, Title = Title, line_width = line_width)\n  dat <- model.frame(formula, data)\n  subject <- 1:nrow(dat)\n  dat2 <- data.frame(dat, subject = subject)\n  nf <- ncol(dat) - 1\n  nadat <- names(dat)\n  nadat2 <- nadat[-1]\n  fl <- NA\n  for (aa in 1:nf) {\n    fl[aa] <- nlevels(as.factor(dat[ ,aa + 1]))\n  }\n  levels <- list()\n  for (jj in 1:nf) {\n    levels[[jj]] <- levels(as.factor(dat[ ,jj + 1]))\n  }\n  lev_names <- expand.grid(levels)\n  \n  if (nf == 1) {\n    # one-way layout\n    dat2 <- dat2[order(dat2[, 2]), ]\n    response <- dat2[, 1]\n    nr_hypo <- attr(terms(formula), \"factors\")\n    fac_names <- colnames(nr_hypo)\n    n <- plyr::ddply(dat2, nadat2, plyr::summarise, Measure = length(subject),\n                     .drop = F)$Measure\n    # contrast matrix\n    hypo <- diag(fl) - matrix(1 / fl, ncol = fl, nrow = fl)\n    WTS_out <- matrix(NA, ncol = 3, nrow = 1)\n    ATS_out <- matrix(NA, ncol = 4, nrow = 1)\n    WTPS_out <- rep(NA, 1)\n    rownames(WTS_out) <- fac_names\n    rownames(ATS_out) <- fac_names\n    names(WTPS_out) <- fac_names\n    results <- Stat(data = response, n = n, hypo, nperm = nperm, alpha)\n    WTS_out <- results$WTS\n    ATS_out <- results$ATS\n    WTPS_out <- results$WTPS\n    mean_out <- results$Mean\n    Var_out <- results$Cov\n    CI <- results$CI\n    colnames(CI) <- c(\"CIl\", \"CIu\")\n    descriptive <- cbind(lev_names, n, mean_out, Var_out, CI)\n    colnames(descriptive) <- c(nadat2, \"n\", \"Means\", \"Variances\",\n                               paste(\"Lower\", 100 * (1 - alpha), \"%\", \"CI\"),\n                               paste(\"Upper\", 100 * (1 - alpha), \"%\", \"CI\"))\n    \n    if (plot_CI == TRUE) {\n      GUIplotOneWay <- function() {\n        plotting <- function(button, user.data) {\n          error <- NULL\n          Title <- filename2$getText()\n          line_width <- as.numeric(filename3$getText())\n          if (!is.null(error)) {\n            hbox <- RGtk2::gtkHBoxNew()\n            vbox$packStart(hbox, FALSE, FALSE, 0)\n            label <- RGtk2::gtkLabel(error)\n            hbox$packStart(label, FALSE, FALSE, 0)\n          }\n          plotrix::plotCI(x = 1:length(levels[[1]]), mean_out, li = descriptive[, 5],\n                          ui = descriptive[, 6], xlab = fac_names, ylab = \"Means\",\n                          col = 1, lwd = line_width, xaxt = \"n\",\n                          xlim = c(0.8, length(levels[[1]]) + 0.3), main = Title,\n                          cex.axis = 1.3, cex.lab = 1.3, font.axis = 2, font.lab = 2)\n          axis(side = 1, at = 1:1:length(levels[[1]]), labels = levels[[1]], las = 0, cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n        }\n        # Create window\n        window <- RGtk2::gtkWindow()\n        # Add title\n        window[\"title\"] <- \"Plot\"\n        # Add a frame\n        frame <- RGtk2::gtkFrameNew(\"Please choose the parameters for your plot.\")\n        window$add(frame)\n        # Create vertical container for file name entry\n        vbox <- RGtk2::gtkVBoxNew(FALSE, 8)\n        vbox$setBorderWidth(24)\n        frame$add(vbox)\n        # Add horizontal container for every widget line\n        hbox <- RGtk2::gtkHBoxNew(FALSE, 8)\n        vbox$packStart(hbox, FALSE, FALSE, 0)\n        # Add an horizontal container to specify parameters\n        hbox <- RGtk2::gtkHBoxNew(FALSE, 8)\n        vbox$packStart(hbox, FALSE, FALSE, 0)\n        label2 <- RGtk2::gtkLabelNewWithMnemonic(\"_Title\")\n        hbox$packStart(label2, FALSE, FALSE, 0)\n        # Add entry in the second column; named \"filename2\"\n        filename2 <- RGtk2::gtkEntryNew()\n        filename2$setWidthChars(10)\n        label2$setMnemonicWidget(filename2)\n        hbox$packStart(filename2, FALSE, FALSE, 0)\n        label3 <- RGtk2::gtkLabelNewWithMnemonic(\"_lwd\")\n        hbox$packStart(label3, FALSE, FALSE, 0)\n        # Add entry in the second column; named \"filename3\"\n        filename3 <- RGtk2::gtkEntryNew()\n        filename3$setWidthChars(10)\n        filename3$setText(2)\n        label3$setMnemonicWidget(filename3)\n        hbox$packStart(filename3, FALSE, FALSE, 0)\n        # Add button\n        the.buttons <- RGtk2::gtkHButtonBoxNew()\n        the.buttons$setBorderWidth(5)\n        vbox$add(the.buttons)\n        the.buttons$setLayout(\"spread\")\n        the.buttons$setSpacing(40)\n        buttonOK <- RGtk2::gtkButtonNewFromStock(\"gtk-ok\")\n        RGtk2::gSignalConnect(buttonOK, \"clicked\", plotting)\n        the.buttons$packStart(buttonOK,fill=F)\n        buttonCancel <- RGtk2::gtkButtonNewFromStock(\"gtk-close\")\n        RGtk2::gSignalConnect(buttonCancel, \"clicked\", window$destroy)\n        the.buttons$packStart(buttonCancel, fill=F)\n      }\n      GUIplotOneWay()\n    }\n    WTS_output <- c(WTS_out, WTPS_out)\n    names(WTS_output) <- cbind (\"Test statistic\", \"df\",\n                                \"p-value\", \"p-value WTPS\")\n    names(ATS_out) <- cbind(\"Test statistic\", \"df1\", \"df2\", \"p-value\")\n    output <- list()\n    output$input <- input_list\n    output$Descriptive <- descriptive\n    output$WTS <- WTS_output\n    output$ATS <- ATS_out\n    # end one-way layout ------------------------------------------------------\n  } else {\n    lev_names <- lev_names[do.call(order, lev_names[, 1:nf]), ]\n    # sorting data according to factors\n    dat2 <- dat2[do.call(order, dat2[, 2:(nf + 1)]), ]\n    response <- dat2[, 1]\n    nr_hypo <- attr(terms(formula), \"factors\")\n    fac_names <- colnames(nr_hypo)\n    fac_names_original <- fac_names\n    perm_names <- t(attr(terms(formula), \"factors\")[-1, ])\n    n <- plyr::ddply(dat2, nadat2, plyr::summarise, Measure = length(subject),\n                     .drop = F)$Measure\n    if (length(fac_names) == nf) {\n      # delete factorcombinations which don't exist\n      n <- n[n != 0]\n    }\n    # mixture of nested and crossed designs is not possible\n    if (length(fac_names) != nf && 2 %in% nr_hypo) {\n      stop(\"A model involving both nested and crossed factors is\n           not impemented!\")\n    }\n    # only 3-way nested designs are possible\n    if (length(fac_names) == nf && nf >= 4) {\n      stop(\"Four- and higher way nested designs are\n           not implemented!\")\n    }\n    # no factor combinations with less than 2 observations\n    if (0 %in% n || 1 %in% n) {\n      stop(\"There is at least one factor-level combination\n           with less than 2 observations!\")\n    }\n    # correct labeling of factors in nested design\n    if (length(fac_names) == nf) {\n      if (nf == 2) {\n        if (all(levels(as.factor(dat2[, 3][dat2[, 2] == levels[[1]][1]]))\n                == levels(as.factor(dat2[, 3][dat2[, 2] == levels[[1]][2]])))) {\n          stop(\"The levels of the nested factor must be\n               named without repetitions!\")\n        }\n      } else if (nf == 3) {\n        if (all(levels(as.factor(dat2[, 3][dat2[, 2] == levels[[1]][1]]))\n                == levels(as.factor(dat2[, 3][dat2[, 2] == levels[[1]][2]]))) ||\n              all(levels(as.factor(dat2[, 4][dat2[, 3] == levels[[2]][1]]))\n                  == levels(as.factor(dat2[, 4][dat2[, 3] == levels[[2]][fl[2] / fl[1] + 1]])))) {\n          stop(\"The levels of the nested factor must be\n                 named without repetitions!\")\n        }\n      }\n    }\n    if (length(fac_names) == nf) {\n      # nested\n      TYPE <- \"nested\"\n      hypo_matrices <- HN(fl)\n      # create correct level combinations\n      blev <- list()\n      lev_names <- list()\n      for (ii in 1:length(levels[[1]])) {\n        blev[[ii]] <- levels(as.factor(dat[, 3][dat[, 2] == levels[[1]][ii]]))\n        lev_names[[ii]] <- rep(levels[[1]][ii], length(blev[[ii]]))\n      }\n      if (nf == 2) {\n        lev_names <- as.factor(unlist(lev_names))\n        blev <- as.factor(unlist(blev))\n        lev_names <- cbind.data.frame(lev_names, blev)\n      } else {\n        lev_names <- lapply(lev_names, rep,\n                            length(levels[[3]]) / length(levels[[2]]))\n        lev_names <- lapply(lev_names, sort)\n        lev_names <- as.factor(unlist(lev_names))\n        blev <- lapply(blev, rep, length(levels[[3]]) / length(levels[[2]]))\n        blev <- lapply(blev, sort)\n        blev <- as.factor(unlist(blev))\n        lev_names <- cbind.data.frame(lev_names, blev, as.factor(levels[[3]]))\n      }\n    } else {\n      # crossed\n      TYPE <- \"crossed\"\n      hypo_matrices <- HC(fl, perm_names, fac_names)[[1]]\n      fac_names <- HC(fl, perm_names, fac_names)[[2]]\n    }\n    if (length(fac_names) != length(hypo_matrices)) {\n      stop(\"Something is wrong: Perhaps a missing interaction term in formula?\")\n    }\n    WTS_out <- matrix(NA, ncol = 3, nrow = length(hypo_matrices))\n    ATS_out <- matrix(NA, ncol = 4, nrow = length(hypo_matrices))\n    WTPS_out <- rep(NA, length(hypo_matrices))\n    rownames(WTS_out) <- fac_names\n    rownames(ATS_out) <- fac_names\n    names(WTPS_out) <- fac_names\n    colnames(ATS_out) <- c(\"Test statistic\", \"df1\", \"df2\", \"p-value\")\n    # calculate results\n    for (i in 1:length(hypo_matrices)) {\n      results <- Stat(data = response, n = n, hypo_matrices[[i]],\n                      nperm = nperm, alpha)\n      WTS_out[i, ] <- results$WTS\n      ATS_out[i, ] <- results$ATS\n      WTPS_out[i] <- results$WTPS\n    }\n    mean_out <- results$Mean\n    Var_out <- results$Cov\n    CI <- results$CI\n    colnames(CI) <- c(\"CIl\", \"CIu\")\n    descriptive <- cbind(lev_names, n, mean_out, Var_out, CI)\n    colnames(descriptive) <- c(nadat2, \"n\", \"Means\", \"Variances\",\n                               paste(\"Lower\", 100 * (1 - alpha),\"%\", \"CI\"),\n                               paste(\"Upper\", 100 * (1 - alpha),\"%\", \"CI\"))\n    \n    # calculate group means, variances and CIs ----------------------------\n    mu <- list()\n    sigma <- list()\n    n_groups <- list()\n    lower <- list()\n    upper <- list()\n    for (i in 1:nf) {\n      mu[[i]] <- c(by(dat2[, 1], dat2[, i + 1], mean))\n      sigma[[i]] <- c(by(dat2[, 1], dat2[, i + 1], var))\n      n_groups[[i]] <- c(by(dat2[, 1], dat2[, i + 1], length))\n      lower[[i]] <- mu[[i]] - sqrt(sigma[[i]] / n_groups[[i]]) *\n        qt(1 - alpha / 2, df = n_groups[[i]])\n      upper[[i]] <- mu[[i]] + sqrt(sigma[[i]] / n_groups[[i]]) *\n        qt(1 - alpha / 2, df = n_groups[[i]])\n    }\n    \n    # Plotting ----------------------------------------------------\n    if (plot_CI == TRUE) {\n      calculateGUIplot <- function() {\n        plotting <- function(button, user.data) {\n          error <- NULL\n          error1 <- NULL\n          Faktor <- filename$getText()\n          Title <- filename2$getText()\n          line_width <- as.numeric(filename3$getText())\n          \n          if (!(Faktor %in% fac_names)) {\n            error1 <- \"Please enter a valid factor name\"\n          }\n                  \n          # plots for interactions\n          if (TYPE == \"nested\") {\n            # main effect\n            if (Faktor == nadat2[1]) {\n              plotrix::plotCI(x = 1:length(levels[[1]]), mu[[1]],\n                              li = lower[[1]], ui = upper[[1]],\n                              xlab = nadat2[[1]], ylab = \"Means\",\n                              col = 1, lwd = line_width, xaxt = \"n\",\n                              xlim = c(0.8, length(levels[[1]]) + 0.3),\n                              main = Title, font.lab = 2,\n                              cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n              axis(side = 1, at = 1:1:length(levels[[1]]), labels = levels[[1]],\n                   las = 0, cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n            } else if (Faktor == fac_names[2] && nf == 2) {\n              for_plots <- cbind(lev_names, mean_out, CI)\n              plotrix::plotCI(x = 1:length(levels[[2]]), for_plots[, 3],\n                              li = for_plots[, 4], ui = for_plots[, 5],\n                              xlab = fac_names[2], ylab = \"Means\",\n                              col = 1, lwd = line_width,\n                              ylim = c(min(CI) - 1, max(CI) + 1),\n                              xaxt = \"n\", xlim = c(0.8, length(levels[[2]]) + 0.3),\n                              cex.axis = 1.3, cex.lab = 1.3,\n                              font.axis = 2, font.lab = 2)\n              title(Title, line = 3)\n              axis(side = 1, at = 1:1:length(levels[[2]]), labels = lev_names[, 2],\n                   las = 0, cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n              aa <- length(levels[[2]]) / fl[1] ^ 2\n              bb <- length(levels[[2]]) / fl[1]\n              cc <- length(levels[[2]]) + aa\n              ss <- seq(from = - aa, to = cc, by = bb)\n              axis(side = 3, at = ss[2:(length(ss) - 1)], labels = levels[[1]],\n                   las = 1, cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n            } else if(Faktor %in% fac_names && nf == 3 && !(Faktor == nadat2[1])) {\n              error <- \"For three-way nested design, only the main effect\n                      can be plotted.\"\n            }}\n          if (TYPE == \"crossed\") {\n            # plot of main effects\n            for (i in 1:nf) {\n              if (Faktor == nadat2[i]) {\n                plotrix::plotCI(x = 1:length(levels[[i]]), mu[[i]],\n                                li = lower[[i]], ui = upper[[i]],\n                                xlab = nadat2[[i]], ylab = \"Means\",\n                                col = 1, lwd = line_width, xaxt = \"n\",\n                                xlim = c(0.8, length(levels[[i]]) + 0.3),\n                                main = Title, font.lab = 2,\n                                cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n                axis(side = 1, at = 1:1:length(levels[[i]]), labels = levels[[i]],\n                     las = 0, cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n              }}\n\n            # two-fold interactions for three- and higher-way layout\n            fac_names_twofold <- fac_names_original[ - (1:nf)]\n            fac_names_twofold <- fac_names_twofold[1:choose(nf, 2)]\n            \n            if (Faktor %in% fac_names_twofold) {\n              nmu <- list()\n              nsigma <- list()\n              nn_groups <- list()\n              nupper <- list()\n              nlower <- list()\n              new_levels <- list()\n              counter <- 1\n              for (i in 2:nf) {\n                for (j in (i + 1):(nf + 1)) {\n                  nmu[[counter]] <- matrix(by(dat2[, 1], dat2[, c(i, j)], mean),\n                                           nrow = fl[i - 1])\n                  nsigma[[counter]] <- matrix(by(dat2[, 1], dat2[, c(i, j)], var),\n                                              nrow = fl[i - 1])\n                  nn_groups[[counter]] <- matrix(by(dat2[, 1], dat2[, c(i, j)],\n                                                    length), nrow = fl[i - 1])\n                  nlower[[counter]] <- nmu[[counter]] -\n                    sqrt(nsigma[[counter]] / nn_groups[[counter]]) *\n                    qt(1 - alpha / 2, df = nn_groups[[counter]])\n                  nupper[[counter]] <- nmu[[counter]] +\n                    sqrt(nsigma[[counter]] / nn_groups[[counter]]) *\n                    qt(1 - alpha / 2, df = nn_groups[[counter]])\n                  new_levels[[counter]] <- list(levels[[i - 1]], levels[[j - 1]])\n                  counter <- counter + 1\n                }\n              }\n              names(nmu) <- fac_names_twofold\n              names(nupper) <- fac_names_twofold\n              names(nlower) <- fac_names_twofold\n              place <- which(Faktor == fac_names_twofold)\n              xxx <- rep(NA, nf)\n              for (ii in 1:nf) {\n                xxx[ii] <- grepl(fac_names_original[ii], Faktor, fixed = TRUE)\n              }\n              pos <- which(xxx == TRUE)[2]\n              pos2 <- which(xxx == TRUE)[1]\n              par(oma = c(6, 3, 2.5, 2.5))\n              plotrix::plotCI(x = 1:length(new_levels[[place]][[2]]),\n                              nmu[[Faktor]][1, ],\n                              li = nlower[[Faktor]][1, ],\n                              ui = nupper[[Faktor]][1, ],\n                              xlab = fac_names_original[pos],\n                              ylab = \"Means\", col = 1,\n                              lwd = line_width,\n                              ylim = c(min(nlower[[Faktor]]) - 1, max(nupper[[Faktor]]) + 1),\n                              xaxt = \"n\",\n                              xlim = c(0.8, length(new_levels[[place]][[2]]) + 0.3),\n                              main = Title,\n                              cex.axis = 1.3, cex.lab = 1.3, font.axis = 2, font.lab = 2)\n              axis(side = 1, at = 1:1:length(new_levels[[place]][[2]]),\n                   labels = new_levels[[place]][[2]], las = 0, cex.axis = 1.3, cex.lab = 1.3,\n                   font.axis = 2)\n              for (i in 2:length(new_levels[[place]][[1]])) {\n                plotrix::plotCI(x = ((1:length(new_levels[[place]][[2]])) + 0.07 * i),\n                                nmu[[Faktor]][i, ], li = nlower[[Faktor]][i, ],\n                                ui = nupper[[Faktor]][i, ], add = TRUE, col = i,\n                                lwd = line_width, cex.axis = 1.3, cex.lab = 1.3,\n                                font.axis = 2, font.lab = 2)\n              }\n              par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0),\n                  new = TRUE)\n              plot(0, 0, type = \"n\", bty = \"n\", xaxt = \"n\", yaxt = \"n\")\n              legend(\"bottom\", xpd = TRUE, horiz = TRUE, inset = c(0, 0),\n                     box.lty = 0,\n                     legend = c(fac_names_original[pos2], new_levels[[place]][[1]]),\n                     col = c(1, 1:length(new_levels[[place]][[1]])), lwd = line_width,\n                     seg.len = 0.5, text.font = 2,\n                     lty = c(NA, rep(1, length(new_levels[[place]][[1]]))))\n            } else if (nf == 3 && Faktor == fac_names[length(fac_names)]) {\n              # three-way\n              Var1 = Var2 = Var3 = CIl = CIu = NULL\n              for_plots <- cbind(lev_names, mean_out, CI)\n              group <- list()\n              for (i in 1:length(levels[[1]])) {\n                group[[i]] <- subset(for_plots, Var1 == as.factor(levels[[1]])[i],\n                                     select = c(Var2, Var3, mean_out, CIl, CIu))\n              }\n              next_group <- list()\n              new_group <- list()\n              for (j in 1:length(group)) {\n                for (l in 1:length(levels[[2]])) {\n                  next_group[[l]] <- subset(group[[j]],\n                                            Var2 == as.factor(levels[[2]])[l],\n                                            select = c(mean_out, CIl, CIu))\n                }\n                new_group[[j]] <- next_group\n              }\n              counter <- 1\n              delta <- seq(from = 0, by = 0.05,\n                           length = length(levels[[1]]) * length(levels[[2]]) + 1)\n              par(oma = c(6, 3, 2.5, 2.5))\n              plotrix::plotCI(x = 1:length(levels[[3]]), new_group[[1]][[1]][, 1],\n                              li = new_group[[1]][[1]][, 2],\n                              ui = new_group[[1]][[1]][, 3],\n                              xlab = fac_names_original[[3]],\n                              ylab = \"Means\", col = 1,\n                              lwd = line_width, pch = 2,\n                              ylim = c(min(CI) - 1, max(CI) + 1),\n                              xaxt = \"n\", xlim = c(0.8, length(levels[[3]]) + 0.3),\n                              main = Title, cex.axis = 1.3, cex.lab = 1.3,\n                              font.axis = 2, font.lab = 2)\n              axis(side = 1, at = 1:1:length(levels[[3]]), labels = levels[[3]],\n                   las = 0, cex.axis = 1.3, cex.lab = 1.3, font.axis = 2)\n              for (j in 1:length(levels[[1]])) {\n                for (i in 1:length(levels[[2]])) {\n                  plotrix::plotCI(x = ((1:length(levels[[3]])) + delta[counter]),\n                                  new_group[[j]][[i]][, 1], li = new_group[[j]][[i]][, 2],\n                                  ui = new_group[[j]][[i]][, 3], add = TRUE, col = i,\n                                  lwd = line_width, pch = 2 * j, cex.axis = 1.3, cex.lab = 1.3,\n                                  font.axis = 2, font.lab = 2)\n                  counter <- counter + 1\n                }}\n              par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)\n              plot(0, 0, type = \"n\", bty = \"n\", xaxt = \"n\", yaxt = \"n\")\n              legend(\"bottomright\", xpd = TRUE, horiz = TRUE, inset = c(0, 0), box.lty = 0,\n                     legend = c(levels[[1]], levels[[2]]),\n                     col = c(rep(1, length(levels[[1]])), 1:length(levels[[2]])),\n                     pch = c(2 * (1:length(levels[[1]])), rep(NA, length(levels[[2]]))),\n                     lwd = line_width, seg.len = 0.5,\n                     lty = c(rep(NA, length(levels[[1]])), rep(1, length(levels[[2]]))),\n                     cex = 0.8, text.font = 2)\n            } else if (Faktor %in% fac_names && nf >= 4) {\n              error <- \"Higher-way interactions cannot be plotted!\"\n            }\n          }\n          if (!is.null(error1)) {\n            hbox <- RGtk2::gtkHBoxNew()\n            vbox$packStart(hbox, FALSE, FALSE, 0)\n            label <- RGtk2::gtkLabel(error1)\n            hbox$packStart(label, FALSE, FALSE, 0)\n          }\n          if (!is.null(error)) {\n            hbox <- RGtk2::gtkHBoxNew()\n            vbox$packStart(hbox, FALSE, FALSE, 0)\n            label <- RGtk2::gtkLabel(error)\n            hbox$packStart(label, FALSE, FALSE, 0)\n          }\n        }\n        # Create window\n        window <- RGtk2::gtkWindow()\n        # Add title\n        window[\"title\"] <- \"Plot\"\n        # Add a frame\n        frame <- RGtk2::gtkFrameNew(\"Please choose the factor you wish to plot (for interaction type something like group1:group2).\")\n        window$add(frame)\n        # Create vertical container for file name entry\n        vbox <- RGtk2::gtkVBoxNew(FALSE, 8)\n        vbox$setBorderWidth(24)\n        frame$add(vbox)\n        # Add horizontal container for every widget line\n        hbox <- RGtk2::gtkHBoxNew(FALSE, 8)\n        vbox$packStart(hbox, FALSE, FALSE, 0)\n        # Add label in first column\n        label <- RGtk2::gtkLabelNewWithMnemonic(\"_Factor\")\n        hbox$packStart(label, FALSE, FALSE, 0)\n        # Add entry in the second column; named \"filename\"\n        filename <- RGtk2::gtkEntryNew()\n        filename$setWidthChars(50)\n        label$setMnemonicWidget(filename)\n        hbox$packStart(filename, FALSE, FALSE, 0)\n        # Add an horizontal container to specify parameters\n        hbox <- RGtk2::gtkHBoxNew(FALSE, 8)\n        vbox$packStart(hbox, FALSE, FALSE, 0)\n        label2 <- RGtk2::gtkLabelNewWithMnemonic(\"_Title\")\n        hbox$packStart(label2, FALSE, FALSE, 0)\n        # Add entry in the second column; named \"filename2\"\n        filename2 <- RGtk2::gtkEntryNew()\n        filename2$setWidthChars(10)\n        label2$setMnemonicWidget(filename2)\n        hbox$packStart(filename2, FALSE, FALSE, 0)\n        label3 <- RGtk2::gtkLabelNewWithMnemonic(\"_lwd\")\n        hbox$packStart(label3, FALSE, FALSE, 0)\n        # Add entry in the second column; named \"filename3\"\n        filename3 <- RGtk2::gtkEntryNew()\n        filename3$setWidthChars(10)\n        filename3$setText(2)\n        label3$setMnemonicWidget(filename3)\n        hbox$packStart(filename3, FALSE, FALSE, 0)\n        # Add button\n        the.buttons <- RGtk2::gtkHButtonBoxNew()\n        the.buttons$setBorderWidth(5)\n        vbox$add(the.buttons)\n        the.buttons$setLayout(\"spread\")\n        the.buttons$setSpacing(40)\n        buttonOK <- RGtk2::gtkButtonNewFromStock(\"gtk-ok\")\n        RGtk2::gSignalConnect(buttonOK, \"clicked\", plotting)\n        the.buttons$packStart(buttonOK, fill=F)\n        buttonCancel <- RGtk2::gtkButtonNewFromStock(\"gtk-close\")\n        RGtk2::gSignalConnect(buttonCancel, \"clicked\", window$destroy)\n        the.buttons$packStart(buttonCancel, fill=F)\n      }\n      calculateGUIplot()\n    }\n    # Output ------------------------------------------------------\n    WTS_output <- cbind(WTS_out, WTPS_out)\n    colnames(WTS_output) <- cbind (\"Test statistic\", \"df\", \"p-value\",\n                                   \"p-value WTPS\")\n    output <- list()\n    output$input <- input_list\n    output$Descriptive <- descriptive\n    output$WTS <- WTS_output\n    output$ATS <- ATS_out\n  }\n  class(output) <- \"GFD\"\n  return(output)\n}\n",
    "created" : 1447761995510.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "873278948",
    "id" : "E2232A96",
    "lastKnownWriteTime" : 1449492581,
    "path" : "~/Documents/Studium/02 Uni Ulm/02 Promotion/R-package/GFD/R/GFD-function.R",
    "project_path" : "R/GFD-function.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}