{
    "collab_server" : "",
    "contents" : "#' Tests for General Factorial Designs\n#' \n#' The GFD function calculates the Wald-type statistic (WTS), the ANOVA-type \n#' statistic (ATS) as well as a permutation version of the WTS for general \n#' factorial designs.\n#' \n#' @param formula A model \\code{\\link{formula}} object. The left hand side\n#'   contains the response variable and the right hand side contains the factor\n#'   variables of interest. An interaction term must be specified.\n#' @param data A data.frame, list or environment containing the variables in \n#'   \\code{formula}. The default option is \\code{NULL}.\n#' @param nperm The number of permutations used for calculating the permuted \n#'   Wald-type statistic. The default option is 10000.\n#' @param alpha A number specifying the significance level; the default is 0.05.\n#' @param nested.levels.unique A logical specifying whether the levels of the nested factor(s)\n#'   are labeled uniquely or not. Default is FALSE, i.e., the levels of the nested \n#'   factor are the same for each level of the main factor.\n#' @param CI.method Method for calculating the confidence intervals. Default is 't-quantile' for\n#'    CIs based on the corresponding t-quantile. Additionally, the quantile of the permutation \n#'    distribution can be used ('perm').\n#' \n#' @details The package provides the Wald-type statistic, a permuted version\n#'   thereof as well as the ANOVA-type statistic for general factorial designs,\n#'   even with non-normal error terms and/or heteroscedastic variances. It is\n#'   implemented for both crossed and hierarchically nested designs and allows\n#'   for an arbitrary number of factor combinations as well as different sample\n#'   sizes in the crossed design.\n#'   The \\code{GFD} function returns three p-values: One for the ATS based on an F-quantile and\n#'   two for the WTS, one based on the \\eqn{\\chi^2}\n#'    distribution and one based on the permutation procedure.\n#'   Since the ATS is only an approximation and the WTS based on the \\eqn{\\chi^2}\n#'   distribution is known \n#'   to be very liberal for small sample sizes, we recommend to use the WTPS in these situations.\n#'\n#'   \n#' @return A \\code{GFD} object containing the following components:\n#' \\item{Descriptive}{Some descriptive statistics of the data for all factor\n#'   level combinations. Displayed are the number of individuals per factor\n#'   level combination, the mean, variance and 100*(1-alpha)\\% confidence\n#'   intervals.}\n#'  \\item{WTS}{The value of the WTS along with degrees of freedom of the central chi-square distribution\n#'   and p-value, as well as the p-value of the permutation procedure.}\n#'  \\item{ATS}{The value of the ATS, degrees of freedom of the central F distribution and \n#'  the corresponding p-value.}\n#' \n#' @examples\n#' GFD(weightgain ~ source * type, data = HSAUR::weightgain, nperm = 1000)\n#' \n#' data(startup)\n#' model <- GFD(Costs ~ company, data = startup, CI.method = \"perm\")\n#' summary(model)\n#' \n#' @references Friedrich, S., Konietschke, F., Pauly, M.(2017). GFD - An R-package\n#' for the Analysis of General Factorial Designs. Journal of Statistical Software, Code Snippets 79(1), \n#' 1--18, doi:10.18637/jss.v079.c01.\n#' \n#' \n#' Pauly, M., Brunner, E., Konietschke, F.(2015). Asymptotic Permutation Tests in General Factorial Designs. \n#' Journal of the Royal Statistical Society - Series B 77, 461-473.\n#' \n#' @importFrom graphics axis legend par plot title\n#' @importFrom stats ecdf formula model.frame pchisq pf qt terms var quantile\n#' @importFrom utils read.table\n#' @importFrom methods hasArg\n#' \n#' @export\n\nGFD <- function(formula, data = NULL, nperm = 10000,\n                alpha = 0.05, nested.levels.unique = FALSE, CI.method = \"t-quantile\"){\n  \n  if (!(CI.method %in% c(\"t-quantile\", \"perm\"))){\n    stop(\"CI.method must be one of 't-quantile' or 'perm'!\")\n  }\n  \n  input_list <- list(formula = formula, data = data,\n                     nperm = nperm, alpha = alpha)\n  dat <- model.frame(formula, data)\n  subject <- 1:nrow(dat)\n  dat2 <- data.frame(dat, subject = subject)\n  nf <- ncol(dat) - 1\n  nadat <- names(dat)\n  nadat2 <- nadat[-1]\n  fl <- NA\n  for (aa in 1:nf) {\n    fl[aa] <- nlevels(as.factor(dat[ ,aa + 1]))\n  }\n  levels <- list()\n  for (jj in 1:nf) {\n    levels[[jj]] <- levels(as.factor(dat[ ,jj + 1]))\n  }\n  lev_names <- expand.grid(levels)\n  \n  if (nf == 1) {\n    # one-way layout\n    dat2 <- dat2[order(dat2[, 2]), ]\n    response <- dat2[, 1]\n    nr_hypo <- attr(terms(formula), \"factors\")\n    fac_names <- colnames(nr_hypo)\n    n <- plyr::ddply(dat2, nadat2, plyr::summarise, Measure = length(subject),\n                     .drop = F)$Measure\n    # contrast matrix\n    hypo <- diag(fl) - matrix(1 / fl, ncol = fl, nrow = fl)\n    WTS_out <- matrix(NA, ncol = 3, nrow = 1)\n    ATS_out <- matrix(NA, ncol = 4, nrow = 1)\n    WTPS_out <- rep(NA, 1)\n    rownames(WTS_out) <- fac_names\n    rownames(ATS_out) <- fac_names\n    names(WTPS_out) <- fac_names\n    results <- Stat(data = response, n = n, hypo, nperm = nperm, alpha, CI.method)\n    WTS_out <- results$WTS\n    ATS_out <- results$ATS\n    WTPS_out <- results$WTPS\n    mean_out <- results$Mean\n    Var_out <- results$Cov\n    CI <- results$CI\n    colnames(CI) <- c(\"CIl\", \"CIu\")\n    descriptive <- cbind(lev_names, n, mean_out, Var_out, CI)\n    colnames(descriptive) <- c(nadat2, \"n\", \"Means\", \"Variances\",\n                               paste(\"Lower\", 100 * (1 - alpha), \"%\", \"CI\"),\n                               paste(\"Upper\", 100 * (1 - alpha), \"%\", \"CI\"))\n    WTS_output <- c(WTS_out, WTPS_out)\n    names(WTS_output) <- cbind (\"Test statistic\", \"df\",\n                                \"p-value\", \"p-value WTPS\")\n    names(ATS_out) <- cbind(\"Test statistic\", \"df1\", \"df2\", \"p-value\")\n    output <- list()\n    output$input <- input_list\n    output$Descriptive <- descriptive\n    output$WTS <- WTS_output\n    output$ATS <- ATS_out\n    output$plotting <- list(levels, fac_names, nf)\n    names(output$plotting) <- c(\"levels\", \"fac_names\", \"nf\")\n    # end one-way layout ------------------------------------------------------\n  } else {\n    lev_names <- lev_names[do.call(order, lev_names[, 1:nf]), ]\n    # sorting data according to factors\n    dat2 <- dat2[do.call(order, dat2[, 2:(nf + 1)]), ]\n    response <- dat2[, 1]\n    nr_hypo <- attr(terms(formula), \"factors\")\n    fac_names <- colnames(nr_hypo)\n    fac_names_original <- fac_names\n    perm_names <- t(attr(terms(formula), \"factors\")[-1, ])\n    n <- plyr::ddply(dat2, nadat2, plyr::summarise, Measure = length(subject),\n                     .drop = F)$Measure\n    \n    # mixture of nested and crossed designs is not possible\n    if (length(fac_names) != nf && 2 %in% nr_hypo) {\n      stop(\"A model involving both nested and crossed factors is\n           not impemented!\")\n    }\n    # only 3-way nested designs are possible\n    if (length(fac_names) == nf && nf >= 4) {\n      stop(\"Four- and higher way nested designs are\n           not implemented!\")\n    }\n   \n    if (length(fac_names) == nf) {\n      # nested\n      TYPE <- \"nested\"\n      \n      # if nested factor is named uniquely\n      if (nested.levels.unique){\n        # delete factorcombinations which don't exist\n        n <- n[n != 0]\n        # create correct level combinations\n        blev <- list()\n        lev_names <- list()\n        for (ii in 1:length(levels[[1]])) {\n          blev[[ii]] <- levels(as.factor(dat[, 3][dat[, 2] == levels[[1]][ii]]))\n          lev_names[[ii]] <- rep(levels[[1]][ii], length(blev[[ii]]))\n        }\n        if (nf == 2) {\n          lev_names <- as.factor(unlist(lev_names))\n          blev <- as.factor(unlist(blev))\n          lev_names <- cbind.data.frame(lev_names, blev)\n        } else {\n          lev_names <- lapply(lev_names, rep,\n                              length(levels[[3]]) / length(levels[[2]]))\n          lev_names <- lapply(lev_names, sort)\n          lev_names <- as.factor(unlist(lev_names))\n          blev <- lapply(blev, rep, length(levels[[3]]) / length(levels[[2]]))\n          blev <- lapply(blev, sort)\n          blev <- as.factor(unlist(blev))\n          lev_names <- cbind.data.frame(lev_names, blev, as.factor(levels[[3]]))\n        }\n        # correct for wrong counting of nested factors\n        if (nf == 2) {\n          fl[2] <- fl[2] / fl[1]\n        } else if (nf == 3) {\n          fl[3] <- fl[3] / fl[2]\n          fl[2] <- fl[2] / fl[1]\n        }\n      }\n      hypo_matrices <- HN(fl)\n      \n    } else {\n      # crossed\n      TYPE <- \"crossed\"\n      hypo_matrices <- HC(fl, perm_names, fac_names)[[1]]\n      fac_names <- HC(fl, perm_names, fac_names)[[2]]\n    }\n    \n    if (length(fac_names) != length(hypo_matrices)) {\n      stop(\"Something is wrong: Perhaps a missing interaction term in formula?\")\n    }\n    \n    # nested design with levels labeled uniquely, but nested.levels.unique = F?\n    if (TYPE == \"nested\" & 0 %in% n & nested.levels.unique == FALSE) {\n      stop(\"The levels of the nested factor are probably labeled uniquely,\n           but nested.levels.unique is not set to TRUE.\")\n    }\n    \n    # no factor combinations with less than 2 observations\n    if (0 %in% n || 1 %in% n) {\n      stop(\"There is at least one factor-level combination\n           with less than 2 observations!\")\n    }\n    \n    WTS_out <- matrix(NA, ncol = 3, nrow = length(hypo_matrices))\n    ATS_out <- matrix(NA, ncol = 4, nrow = length(hypo_matrices))\n    WTPS_out <- rep(NA, length(hypo_matrices))\n    rownames(WTS_out) <- fac_names\n    rownames(ATS_out) <- fac_names\n    names(WTPS_out) <- fac_names\n    colnames(ATS_out) <- c(\"Test statistic\", \"df1\", \"df2\", \"p-value\")\n    # calculate results\n    for (i in 1:length(hypo_matrices)) {\n      results <- Stat(data = response, n = n, hypo_matrices[[i]],\n                      nperm = nperm, alpha, CI.method)\n      WTS_out[i, ] <- results$WTS\n      ATS_out[i, ] <- results$ATS\n      WTPS_out[i] <- results$WTPS\n    }\n    mean_out <- results$Mean\n    Var_out <- results$Cov\n    CI <- results$CI\n    colnames(CI) <- c(\"CIl\", \"CIu\")\n    descriptive <- cbind(lev_names, n, mean_out, Var_out, CI)\n    colnames(descriptive) <- c(nadat2, \"n\", \"Means\", \"Variances\",\n                               paste(\"Lower\", 100 * (1 - alpha),\"%\", \"CI\"),\n                               paste(\"Upper\", 100 * (1 - alpha),\"%\", \"CI\"))\n    \n    # calculate group means, variances and CIs ----------------------------\n    mu <- list()\n    sigma <- list()\n    n_groups <- list()\n    lower <- list()\n    upper <- list()\n    for (i in 1:nf) {\n      mu[[i]] <- c(by(dat2[, 1], dat2[, i + 1], mean))\n      sigma[[i]] <- c(by(dat2[, 1], dat2[, i + 1], var))\n      n_groups[[i]] <- c(by(dat2[, 1], dat2[, i + 1], length))\n      lower[[i]] <- mu[[i]] - sqrt(sigma[[i]] / n_groups[[i]]) *\n        qt(1 - alpha / 2, df = n_groups[[i]])\n      upper[[i]] <- mu[[i]] + sqrt(sigma[[i]] / n_groups[[i]]) *\n        qt(1 - alpha / 2, df = n_groups[[i]])\n    }\n       \n    # Output ------------------------------------------------------\n    WTS_output <- cbind(WTS_out, WTPS_out)\n    colnames(WTS_output) <- cbind (\"Test statistic\", \"df\", \"p-value\",\n                                   \"p-value WTPS\")\n    output <- list()\n    output$input <- input_list\n    output$Descriptive <- descriptive\n    output$WTS <- WTS_output\n    output$ATS <- ATS_out\n    output$plotting <- list(levels, fac_names, nf, TYPE, mu, lower, upper, fac_names_original, dat2, fl, alpha, nadat2, lev_names)\n    names(output$plotting) <- c(\"levels\", \"fac_names\", \"nf\", \"Type\", \"mu\", \"lower\", \"upper\", \"fac_names_original\", \"dat2\", \"fl\", \"alpha\", \"nadat2\", \"lev_names\")\n  }\n  class(output) <- \"GFD\"\n  return(output)\n}\n",
    "created" : 1460636918524.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "616370371",
    "id" : "FEBB1B54",
    "lastKnownWriteTime" : 1513603831,
    "last_content_update" : 1513603831684,
    "path" : "~/Documents/Studium/02 Uni Ulm/02 Promotion/R-packages/GFD/R/GFD-function.R",
    "project_path" : "R/GFD-function.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}